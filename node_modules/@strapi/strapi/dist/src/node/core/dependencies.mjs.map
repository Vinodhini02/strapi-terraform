{"version":3,"file":"dependencies.mjs","sources":["../../../../src/node/core/dependencies.ts"],"sourcesContent":["import os from 'node:os';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport semver, { SemVer } from 'semver';\nimport resolveFrom from 'resolve-from';\nimport execa, { CommonOptions, ExecaReturnValue } from 'execa';\nimport readPkgUp, { PackageJson } from 'read-pkg-up';\nimport type { BuildOptions } from '../build';\nimport { getPackageManager } from './managers';\n\n/**\n * From V5 this will be imported from the package.json of `@strapi/strapi`.\n */\nconst PEER_DEPS = {\n  react: '^18.0.0',\n  'react-dom': '^18.0.0',\n  'react-router-dom': '^6.0.0',\n  'styled-components': '^6.0.0',\n};\n\ninterface CheckRequiredDependenciesResult {\n  didInstall: boolean;\n}\n\ninterface DepToInstall {\n  name: string;\n  wantedVersion: string;\n  declaredVersion?: never;\n}\n\n/**\n * Checks the user's project that it has declared and installed the required dependencies\n * needed by the Strapi admin project. Whilst generally speaking most modules will be\n * declared by the actual packages there are some packages where you only really want one of\n * and thus they are declared as peer dependencies â€“ react / styled-components / etc.\n *\n * If these deps are not installed or declared, then we prompt the user to correct this. In\n * V4 this is not a hard requirement, but in V5 it will be. Might as well get people started now.\n */\nconst checkRequiredDependencies = async ({\n  cwd,\n  logger,\n}: Pick<BuildOptions, 'cwd' | 'logger'>): Promise<CheckRequiredDependenciesResult> => {\n  /**\n   * This enables us to use experimental deps for libraries like\n   * react or styled-components. This is useful for testing against.\n   */\n  if (process.env.USE_EXPERIMENTAL_DEPENDENCIES === 'true') {\n    logger.warn('You are using experimental dependencies that may not be compatible with Strapi.');\n    return { didInstall: false };\n  }\n\n  const pkg = await readPkgUp({ cwd });\n\n  if (!pkg) {\n    throw new Error(`Could not find package.json at path: ${cwd}`);\n  }\n\n  logger.debug('Loaded package.json:', os.EOL, pkg.packageJson);\n\n  interface DepToReview {\n    name: string;\n    wantedVersion: string;\n    declaredVersion: string;\n  }\n\n  /**\n   * Run through each of the peer deps and figure out if they need to be\n   * installed or they need their version checked against.\n   */\n  const { install, review } = Object.entries(PEER_DEPS).reduce<{\n    install: DepToInstall[];\n    review: DepToReview[];\n  }>(\n    (acc, [name, version]) => {\n      if (!pkg.packageJson.dependencies) {\n        throw new Error(`Could not find dependencies in package.json at path: ${cwd}`);\n      }\n\n      const declaredVersion = pkg.packageJson.dependencies[name];\n\n      if (!declaredVersion) {\n        acc.install.push({\n          name,\n          wantedVersion: version,\n        });\n      } else {\n        acc.review.push({\n          name,\n          wantedVersion: version,\n          declaredVersion,\n        });\n      }\n\n      return acc;\n    },\n    {\n      install: [],\n      review: [],\n    }\n  );\n\n  if (install.length > 0) {\n    logger.info(\n      'The Strapi admin needs to install the following dependencies:',\n      os.EOL,\n      install.map(({ name, wantedVersion }) => `  - ${name}@${wantedVersion}`).join(os.EOL)\n    );\n\n    await installDependencies(install, {\n      cwd,\n      logger,\n    });\n\n    const [file, ...args] = process.argv;\n\n    /**\n     * Re-run the same command after installation e.g. strapi build because the yarn.lock might\n     * not be the same and could break installations. It's not the best solution, but it works.\n     */\n    await execa(file, args, { cwd, stdio: 'inherit' });\n    return { didInstall: true };\n  }\n\n  if (review.length) {\n    const errors: string[] = [];\n\n    for (const dep of review) {\n      // The version specified in package.json could be incorrect, eg `foo`\n      let minDeclaredVersion: SemVer | null = null;\n      try {\n        minDeclaredVersion = semver.minVersion(dep.declaredVersion);\n      } catch (err) {\n        // Intentional fall-through (variable will be left as null, throwing below)\n      }\n\n      if (!minDeclaredVersion) {\n        errors.push(\n          `The declared dependency, ${dep.name} has an invalid version in package.json: ${dep.declaredVersion}`\n        );\n      } else if (!semver.satisfies(minDeclaredVersion, dep.wantedVersion)) {\n        /**\n         * The delcared version should be semver compatible with our required version\n         * of the dependency. If it's not, we should advise the user to change it.\n         */\n        logger.warn(\n          [\n            `Declared version of ${dep.name} (${minDeclaredVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\n            'You may experience issues, we recommend you change this.',\n          ].join(os.EOL)\n        );\n      }\n\n      const installedVersion = await getModuleVersion(dep.name, cwd);\n\n      if (!installedVersion) {\n        /**\n         * TODO: when we know the packageManager we can advise the actual install command.\n         */\n        errors.push(\n          `The declared dependency, ${dep.name} is not installed. You should install before re-running this command`\n        );\n      } else if (!semver.satisfies(installedVersion, dep.wantedVersion)) {\n        logger.warn(\n          [\n            `Declared version of ${dep.name} (${installedVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\n            'You may experience issues, we recommend you change this.',\n          ].join(os.EOL)\n        );\n      }\n    }\n\n    if (errors.length > 0 && process.env.NODE_ENV === 'development') {\n      throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);\n    }\n  }\n\n  return { didInstall: false };\n};\n\nconst getModule = async (name: string, cwd: string): Promise<PackageJson | null> => {\n  const modulePackagePath = resolveFrom.silent(cwd, path.join(name, 'package.json'));\n  if (!modulePackagePath) {\n    return null;\n  }\n  const file = await fs.readFile(modulePackagePath, 'utf8').then((res) => JSON.parse(res));\n\n  return file;\n};\n\nconst getModuleVersion = async (name: string, cwd: string): Promise<string | null> => {\n  const pkg = await getModule(name, cwd);\n\n  return pkg?.version || null;\n};\n\nconst installDependencies = async (\n  install: DepToInstall[],\n  { cwd, logger }: Pick<BuildOptions, 'cwd' | 'logger'>\n) => {\n  const packageManager = getPackageManager();\n\n  if (!packageManager) {\n    logger.error(\n      'Could not find a supported package manager, please install the dependencies manually.'\n    );\n    process.exit(1);\n  }\n\n  const execOptions: CommonOptions<'utf8'> = {\n    encoding: 'utf8',\n    cwd,\n    stdio: 'inherit',\n  };\n\n  const packages = install.map(({ name, wantedVersion }) => `${name}@${wantedVersion}`);\n\n  let result: ExecaReturnValue<string> | undefined;\n\n  if (packageManager === 'npm') {\n    const npmArgs = ['install', '--legacy-peer-deps', '--save', ...packages];\n    logger.info(`Running 'npm ${npmArgs.join(' ')}'`);\n    result = await execa('npm', npmArgs, execOptions);\n  } else if (packageManager === 'yarn') {\n    const yarnArgs = ['add', ...packages];\n    logger.info(`Running 'yarn ${yarnArgs.join(' ')}'`);\n    result = await execa('yarn', yarnArgs, execOptions);\n  } else if (packageManager === 'pnpm') {\n    const pnpmArgs = ['add', '--save-prod', ...packages];\n    logger.info(`Running 'pnpm ${pnpmArgs.join(' ')}'`);\n    result = await execa('pnpm', pnpmArgs, execOptions);\n  }\n\n  if (result?.exitCode || result?.failed) {\n    throw ne